#lang at-exp racket

(require syntax/parse
         mutate
         mutate/traversal
         mutate/logger
         "./read-module.rkt")

(define (get-source-location stx)
  (let ([source (syntax-source stx)]
        [line (syntax-line stx)]
        [column (syntax-column stx)])
    (format "File: ~a, Line: ~a, Column: ~a" source line column)))

(define stx->mutants
    (build-mutation-engine
    #:mutators
    (define-simple-mutator (aod-add stx)
        #:pattern ({~datum +} arg ...)
        (for/stream ([args (in-list (attribute arg))])
        #`(begin #,@args)))
    (define-simple-mutator (aod-minus stx)
        #:pattern ({~datum -} arg ...)
        (for/stream ([args (in-list (attribute arg))])
        #`(begin #,@args)))
    (define-simple-mutator (aod-mul stx)
        #:pattern ({~datum *} arg ...)
        (for/stream ([args (in-list (attribute arg))])
        #`(begin #,@args)))
    (define-simple-mutator (aod-div stx)
        #:pattern ({~datum /} arg ...)
        (for/stream ([args (in-list (attribute arg))])
        #`(begin #,@args)))
    (define-simple-mutator (aod-mod stx)
        #:pattern ({~datum modulo} arg ...)
        (for/stream ([args (in-list (attribute arg))])
        #`(begin #,@args)))
    ; (define-simple-mutator (aod-minus stx)
    ;     #:pattern ({~datum -} arg ...)
    ;     (for/stream ([args (in-permutations (attribute arg))])
    ;     (first args)))
    ; (define-simple-mutator (aod-mul stx)
    ;     #:pattern ({~datum *} arg ...)
    ;     (for/stream ([args (in-permutations (attribute arg))])
    ;     (first args)))
    ; (define-simple-mutator (aod-div stx)
    ;     #:pattern ({~datum /} arg ...)
    ;     (for/stream ([args (in-permutations (attribute arg))])
    ;     (first args)))
    ; (define-simple-mutator (aod-mod stx)
    ;     #:pattern ({~datum modulo} arg ...)
    ;     (for/stream ([args (in-permutations (attribute arg))])
    ;     (first args)))
    ; (define-simple-mutator (permute-cond stx)
    (define-simple-mutator (permute-cond stx)
        #:pattern ({~datum cond} [tests argses ...] ...)
        (for/stream ([args (in-list (attribute argses))])
          #`(begin #,@args)))
    (define-simple-mutator (take-first-if stx)
          #:pattern ({~datum if} test then else)
          #'then)
    (define-simple-mutator (take-second-if stx)
          #:pattern ({~datum if} test then else)
          #'else)
   #:syntax-only
   #:top-level-selector select-define-body
   #:streaming
   #:module-mutator))
(printf "Mutators loaded\n")
(define (get-mutants p)
  (stx->mutants (read-module p)))
(printf "Mutants generated\n")
(define log-receiver
  (make-log-receiver mutate-logger 'info))

(define filepath
  (vector-ref (current-command-line-arguments) 0))

(define out
  (open-output-file "mutant-output.txt" #:exists 'truncate))

(define (extract-mutation-info)
  (let ([log-entry (sync log-receiver)])
    (define third-val (vector-ref log-entry 2))
    (values third-val)))

;; run the given program with the given argument for a maximum of the given number
;; of seconds, return a list containing the two resulting strings for stdout and stderr
;; func copied from JC - CR
(define (subprocess/noinput/timeout timeout-secs prog . args)
  (define-values (the-subprocess sub-stdout sub-stdin sub-stderr)
    (apply
     subprocess #f #f #f 'new
     prog args))
  ;; no need to send input to subprocess, close it now:
  (close-output-port sub-stdin)
  ;; create the timer thread
  (define timer-thread (thread (Î» () (sleep timeout-secs) 'timeout)))
  ;; wait for either the timer thread or the subprocess to finish:
  (define sync-result
    (time (sync timer-thread the-subprocess)))
  (when (thread? sync-result)
    (printf "timeout! must kill subprocess\n")
    ;; timeout! kill the subprocess
    (subprocess-kill the-subprocess #f))
  ;; grab the text from the stdout and stderr pipes
  (define stdout-text (first (regexp-match #px".*" sub-stdout)))
  (define stderr-text (first (regexp-match #px".*" sub-stderr)))
  (close-input-port sub-stdout)
  (close-input-port sub-stderr)
  (list stdout-text stderr-text (subprocess-status the-subprocess)))

; (printf "getting total mutants\n")
(define mutants (stream->list(get-mutants filepath)))
; (printf "All the")
(define total-mutants (length mutants))
; (printf "Total mutants: ~a\n" total-mutants)
(define elapsed-time 0)

; (define total-mutants 100)

(define score
  (for/fold ([failure 0]
             [total 0]
             #:result (/ failure total))
            ([mutant-stx (get-mutants filepath)])
    (define temp (make-temporary-file  "mutant-~a"))
    ; Add timing information - CR
    (define start-time (current-inexact-milliseconds))
    (write-to-file (syntax->datum mutant-stx) temp #:exists 'replace)
    ;; the handling of the logger here is weird. All of the
    ;; messages (events) in this queue are already queued before
    ;; the loop starts, generated by get-mutants. This code
    ;; pulls them out one at a time, and I believe they will
    ;; have to come out in the right order. I'm kind of not a fan
    ;; of this way of writing the code. Indeed, it seems a bit
    ;; weird to use a logger here at all.
    (match (sync log-receiver)
      [(vector level message (list type from-stx to-stx) logger-topic)
        ;; print out the message:
        ; I write to a file and then use python to parse the strings into JSON,
        ; It's not smart, in any way - CR
        (write (format "/#:NUM MUTANT: ~a:#/" total) out)
        (write (format "/#:MUTANT USED: ~a:#/" type) out)
        (write (format "/#:MUTANT SOURCE: ~a:#/" from-stx) out)
        (write (format "/#:MUTANT DESTINATION: ~a:#/" to-stx) out)
        ; Tests if the tests-pass
        (match-define (list stdout-text stderr-text tests-pass?)
          (time (subprocess/noinput/timeout 10 (find-executable-path "raco") "test" temp)))
        (delete-file temp)

        (printf "STDOUT: ~a\n" stdout-text)
        (printf "STDERR: ~a\n" stderr-text)
        (printf "Tests passed? ~a\n" tests-pass?)
        ; Just logging information, remove later - CR
        (define end-time (current-inexact-milliseconds))
        (+ elapsed-time (- end-time start-time))
        (define time-diff (/ (- end-time start-time) 1000))
        (printf "Time taken: ~a\n" time-diff)
        (printf "total ran mutants: ~a\n" total)
        (printf "Estimated time remaining: ~a\n" (* time-diff (- total-mutants total)))
        (printf "Tests passed? ~a, \n" tests-pass?)
        ; Write the results to a file - CR
        (cond 
              [(equal? tests-pass? 0)
              (write "MUTANT_RESULT: passed//##::##//" out)]
              [else
              (write "MUTANT_RESULT: failed//##::##//" out)])
        (values (+ failure (if (equal? tests-pass? 0) 0 1))
              (add1 total))]
      [other
        (printf "unexpected log message: ~e\n" other)
        (error 'message "unexpected log message: ~e" other)])))
    

(write (~a "\n\n\nMutation score: " (~r score)) out)
(printf "Mutation score: ~a\n" score)
(close-output-port out)